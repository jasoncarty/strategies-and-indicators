<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Details - {{ test.strategy_name }}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; padding: 20px; background-color: #f8f9fa; color: #333; }
        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 20px 40px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        h1, h2 { color: #2c3e50; border-bottom: 2px solid #e9ecef; padding-bottom: 10px; margin-top: 30px; }
        h1 { font-size: 2em; }
        .breadcrumb { margin-bottom: 20px; }
        .breadcrumb a { color: #007bff; text-decoration: none; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid #007bff; }
        .stat-value { font-size: 1.8em; font-weight: 600; color: #0056b3; }
        .stat-label { color: #666; margin-top: 5px; font-size: 0.9em; }
        .profit-positive { color: #28a745; }
        .profit-negative { color: #dc3545; }
        .chart-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 30px; margin-top: 30px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f8f9fa; font-weight: bold; }
        tr:hover { background-color: #f1f1f1; }
        /* Score Breakdown Tooltip */
        .score-breakdown {
            position: relative;
            cursor: help;
        }
        .score-breakdown:hover::after {
            content: attr(data-breakdown);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        /* Parameters Section Styles */
        .parameters-container {
            margin: 20px 0;
        }
        .parameter-category {
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
        }
        .category-header {
            background: #f8f9fa;
            margin: 0;
            padding: 15px 20px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .category-header:hover {
            background: #e9ecef;
        }
        .toggle-icon {
            font-size: 12px;
            transition: transform 0.2s;
        }
        .category-content {
            padding: 20px;
            background: white;
        }
        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .parameter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }
        .parameter-name {
            font-weight: 500;
            color: #495057;
            flex: 1;
        }
        .parameter-value {
            font-weight: 600;
            color: #212529;
            text-align: right;
            min-width: 80px;
        }
        .value-true {
            color: #28a745;
            font-weight: bold;
        }
        .value-false {
            color: #dc3545;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="breadcrumb"><a href="/dashboard">&larr; Back to Dashboard</a></div>
        <h1>{{ test.strategy_name }} <span style="font-size: 0.6em; color: #666;">on {{ test.symbol }} ({{ test.timeframe }})</span></h1>

        <h2>Overall Performance</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value {{ 'profit-positive' if test.profit >= 0 else 'profit-negative' }}">${{ "%.2f"|format(test.profit) }}</div>
                <div class="stat-label">Total Net Profit</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{ "%.2f"|format(test.profit_factor) }}</div>
                <div class="stat-label">Profit Factor</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{ "%.2f"|format(test.win_rate) }}%</div>
                <div class="stat-label">Win Rate</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{ "%.2f"|format(test.max_drawdown) }}%</div>
                <div class="stat-label">Max Drawdown</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{ test.total_trades }}</div>
                <div class="stat-label">Total Trades</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{ "%.2f"|format(test.recovery_factor) }}</div>
                <div class="stat-label">Recovery Factor</div>
            </div>
             <div class="stat-card">
                <div class="stat-value">{{ "%.2f"|format(test.sharpe_ratio) }}</div>
                <div class="stat-label">Sharpe Ratio</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{ "%.2f"|format(test.expected_payoff) }}</div>
                <div class="stat-label">Expected Payoff</div>
            </div>
        </div>

        <h2>Strategy Parameters</h2>
        <div id="parameters-section">
            <div style="text-align: center; padding: 20px;">
                <p>Loading parameters...</p>
            </div>
        </div>

        <h2>Profit/Loss Analysis</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value profit-positive">${{ "%.2f"|format(test.gross_profit) }}</div>
                <div class="stat-label">Gross Profit</div>
            </div>
            <div class="stat-card">
                <div class="stat-value profit-negative">${{ "%.2f"|format(test.gross_loss) }}</div>
                <div class="stat-label">Gross Loss</div>
            </div>
            <div class="stat-card">
                <div class="stat-value profit-positive">${{ "%.2f"|format(test.largest_profit) }}</div>
                <div class="stat-label">Largest Profit</div>
            </div>
            <div class="stat-card">
                <div class="stat-value profit-negative">${{ "%.2f"|format(test.largest_loss) }}</div>
                <div class="stat-label">Largest Loss</div>
            </div>
            <div class="stat-card">
                <div class="stat-value profit-positive">${{ "%.2f"|format(test.avg_profit) }}</div>
                <div class="stat-label">Average Profit</div>
            </div>
            <div class="stat-card">
                <div class="stat-value profit-negative">${{ "%.2f"|format(test.avg_loss) }}</div>
                <div class="stat-label">Average Loss</div>
            </div>
        </div>

        <h2>Trade Analysis</h2>
        <div class="stats-grid">
             <div class="stat-card">
                <div class="stat-value">{{ test.long_trades }}</div>
                <div class="stat-label">Long Trades</div>
            </div>
             <div class="stat-card">
                <div class="stat-value">{{ test.short_trades }}</div>
                <div class="stat-label">Short Trades</div>
            </div>
             <div class="stat-card">
                <div class="stat-value">{{ "%.2f"|format(100 * test.long_trades_won / test.long_trades if test.long_trades > 0 else 0) }}%</div>
                <div class="stat-label">Longs Won</div>
            </div>
             <div class="stat-card">
                <div class="stat-value">{{ "%.2f"|format(100 * test.short_trades_won / test.short_trades if test.short_trades > 0 else 0) }}%</div>
                <div class="stat-label">Shorts Won</div>
            </div>
        </div>

        <h2>Consecutive Trades</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value">{{ test.max_consecutive_wins }}</div>
                <div class="stat-label">Max Consecutive Wins</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{ test.max_consecutive_losses }}</div>
                <div class="stat-label">Max Consecutive Losses</div>
            </div>
             <div class="stat-card">
                <div class="stat-value">{{ test.avg_consecutive_wins }}</div>
                <div class="stat-label">Avg Consecutive Wins</div>
            </div>
             <div class="stat-card">
                <div class="stat-value">{{ test.avg_consecutive_losses }}</div>
                <div class="stat-label">Avg Consecutive Losses</div>
            </div>
        </div>

        <h2>Performance Charts</h2>
        <div class="chart-container">
            <div>
                <h3>Equity Curve</h3>
                <canvas id="equityCurveChart"></canvas>
            </div>
            <div>
                <h3>Hourly Performance</h3>
                <canvas id="hourlyPerformanceChart"></canvas>
            </div>
            <div>
                <h3>Daily Performance</h3>
                <canvas id="dailyPerformanceChart"></canvas>
            </div>
             <div>
                <h3>Monthly Performance</h3>
                <canvas id="monthlyPerformanceChart"></canvas>
            </div>
        </div>

        <h2>Trading Conditions Analysis</h2>
        <div class="chart-container">
            <div>
                <h3>Trade Duration Distribution</h3>
                <canvas id="tradeDurationChart"></canvas>
            </div>
            <div>
                <h3>Win/Loss Distribution</h3>
                <canvas id="winLossDistributionChart"></canvas>
            </div>
            <div>
                <h3>Trade Volume by Hour</h3>
                <canvas id="tradeVolumeByHourChart"></canvas>
            </div>
            <div>
                <h3>Average Profit by Trade Duration</h3>
                <canvas id="profitByDurationChart"></canvas>
            </div>
        </div>

        <h2>Entry/Exit Analysis</h2>
        <div class="chart-container">
            <div>
                <h3>Trade Entry Times</h3>
                <canvas id="entryTimesChart"></canvas>
            </div>
            <div>
                <h3>Long vs Short Performance</h3>
                <canvas id="longShortChart"></canvas>
            </div>
            <div>
                <h3>Consecutive Wins/Losses</h3>
                <canvas id="consecutiveChart"></canvas>
            </div>
            <div>
                <h3>Profit Distribution</h3>
                <canvas id="profitDistributionChart"></canvas>
            </div>
        </div>

        <h2>Trading Conditions Analysis</h2>
        <div class="chart-container">
            <div>
                <h3>Kill Zone Performance</h3>
                <canvas id="killZoneChartCount"></canvas>
                <canvas id="killZoneChartProfit"></canvas>
            </div>
            <div>
                <h3>FVG Impact on Performance</h3>
                <canvas id="fvgImpactChartCount"></canvas>
                <canvas id="fvgImpactChartProfit"></canvas>
            </div>
            <div>
                <h3>Market Structure Alignment</h3>
                <canvas id="marketStructureChartCount"></canvas>
                <canvas id="marketStructureChartProfit"></canvas>
            </div>
            <div>
                <h3>Volume Confirmation Impact</h3>
                <canvas id="volumeConfirmationChartCount"></canvas>
                <canvas id="volumeConfirmationChartProfit"></canvas>
            </div>
        </div>

        <h2>ICT Strategy Conditions</h2>
        <div class="chart-container">
            <div>
                <h3>OTE Point Performance</h3>
                <canvas id="otePerformanceChartCount"></canvas>
                <canvas id="otePerformanceChartProfit"></canvas>
            </div>
            <div>
                <h3>Lower Timeframe Break Impact</h3>
                <canvas id="ltfBreakChartCount"></canvas>
                <canvas id="ltfBreakChartProfit"></canvas>
            </div>
            <div>
                <h3>Fibonacci Level Performance</h3>
                <canvas id="fibPerformanceChartCount"></canvas>
                <canvas id="fibPerformanceChartProfit"></canvas>
            </div>
            <div>
                <h3>Order Block Performance</h3>
                <canvas id="orderBlockChartCount"></canvas>
                <canvas id="orderBlockChartProfit"></canvas>
            </div>
        </div>

        <h2 class="all-trades-header">All Trades (0)</h2>
        <table>
            <thead>
                <tr>
                    <th>Ticket</th>
                    <th>Type</th>
                    <th>Volume</th>
                    <th>Open Time</th>
                    <th>Net Profit</th>
                </tr>
            </thead>
            <tbody id="trades-table-body">
                <!-- Trades will be populated by JavaScript -->
            </tbody>
        </table>
    </div>

    <script>
        // Chart.js instance management
        const chartInstances = {};
        function createOrUpdateChart(canvasId, config) {
            if (chartInstances[canvasId]) {
                chartInstances[canvasId].destroy();
            }
            const ctx = document.getElementById(canvasId).getContext('2d');
            chartInstances[canvasId] = new Chart(ctx, config);
        }

        document.addEventListener('DOMContentLoaded', function () {
            const testId = window.location.pathname.split('/').pop();
            const container = document.querySelector('.container');

            if (!testId || !/^\d+$/.test(testId)) {
                container.innerHTML = '<h1>Error</h1><p>Could not determine a valid Test ID from the URL.</p>';
                return;
            }

            const formatCurrency = (value) => (value != null ? value.toFixed(2) : '0.00');
            const formatPercent = (value) => (value != null ? value.toFixed(2) : '0.00');
            const getProfitClass = (value) => (value >= 0 ? 'profit-positive' : 'profit-negative');

            function createBarChart(canvasId, labels, data, chartLabel) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: chartLabel,
                            data: data,
                            backgroundColor: data.map(v => v >= 0 ? 'rgba(40, 167, 69, 0.7)' : 'rgba(220, 53, 69, 0.7)'),
                            borderColor: data.map(v => v >= 0 ? 'rgba(40, 167, 69, 1)' : 'rgba(220, 53, 69, 1)'),
                            borderWidth: 1
                        }]
                    },
                    options: { scales: { y: { beginAtZero: true } }, plugins: { legend: { display: true } } }
                });
            }

            fetch(`/api/test/${testId}`)
                .then(response => {
                    if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                    return response.json();
                })
                .then(test => {
                    document.title = `Test Details - ${test.strategy_name}`;
                    container.querySelector('h1').innerHTML = `${test.strategy_name} <span style="font-size: 0.6em; color: #666;">on ${test.symbol} (${test.timeframe})</span>`;

                    const statsMap = {
                        'Total Net Profit': { value: `$${formatCurrency(test.profit)}`, class: getProfitClass(test.profit) },
                        'Profit Factor': { value: formatCurrency(test.profit_factor) },
                        'Win Rate': { value: `${formatPercent(test.win_rate)}%` },
                        'Max Drawdown': { value: `${formatPercent(test.max_drawdown)}%` },
                        'Total Trades': { value: test.total_trades },
                        'Recovery Factor': { value: formatCurrency(test.recovery_factor) },
                        'Sharpe Ratio': { value: formatCurrency(test.sharpe_ratio) },
                        'Expected Payoff': { value: formatCurrency(test.expected_payoff) },
                        'Gross Profit': { value: `$${formatCurrency(test.gross_profit)}`, class: 'profit-positive' },
                        'Gross Loss': { value: `$${formatCurrency(test.gross_loss)}`, class: 'profit-negative' },
                        'Largest Profit': { value: `$${formatCurrency(test.largest_profit)}`, class: 'profit-positive' },
                        'Largest Loss': { value: `$${formatCurrency(test.largest_loss)}`, class: 'profit-negative' },
                        'Average Profit': { value: `$${formatCurrency(test.avg_profit)}`, class: 'profit-positive' },
                        'Average Loss': { value: `$${formatCurrency(test.avg_loss)}`, class: 'profit-negative' },
                        'Long Trades': { value: test.long_trades },
                        'Short Trades': { value: test.short_trades },
                        'Longs Won': { value: `${formatPercent(100 * test.long_trades_won / (test.long_trades || 1))}%` },
                        'Shorts Won': { value: `${formatPercent(100 * test.short_trades_won / (test.short_trades || 1))}%` },
                        'Max Consecutive Wins': { value: test.max_consecutive_wins },
                        'Max Consecutive Losses': { value: test.max_consecutive_losses },
                        'Avg Consecutive Wins': { value: test.avg_consecutive_wins },
                        'Avg Consecutive Losses': { value: test.avg_consecutive_losses }
                    };

                    container.querySelectorAll('.stat-card').forEach(card => {
                        const label = card.querySelector('.stat-label').textContent;
                        const valueDiv = card.querySelector('.stat-value');
                        if (statsMap[label] && valueDiv) {
                            valueDiv.innerHTML = statsMap[label].value;
                            valueDiv.className = 'stat-value';
                            if(statsMap[label].class) valueDiv.classList.add(statsMap[label].class);
                        }
                    });

                    const tableBody = document.getElementById('trades-table-body');
                    container.querySelector('h2.all-trades-header').textContent = `All Trades (${test.trades.length})`;
                    tableBody.innerHTML = test.trades.map(trade => `<tr>
                        <td>${trade.ticket}</td>
                        <td>${trade.type}</td>
                        <td>${trade.volume}</td>
                        <td>${new Date(trade.open_time).toLocaleString()}</td>
                        <td class="${getProfitClass(trade.net_profit)}">${formatCurrency(trade.net_profit)}</td>
                    </tr>`).join('');

                    const { trades, initial_deposit } = test;
                    if (!trades || trades.length === 0) return;

                    let equity = initial_deposit;
                    const equityData = trades.map(trade => equity += trade.net_profit);
                    createOrUpdateChart('equityCurveChart', { type: 'line', data: { labels: Array.from({ length: trades.length }, (_, i) => `Trade ${i + 1}`), datasets: [{ label: 'Equity', data: equityData, borderColor: '#007bff', backgroundColor: 'rgba(0, 123, 255, 0.1)', fill: true, tension: 0.1, pointRadius: 0 }] }, options: { scales: { x: { title: { display: true, text: 'Trade Number' } }, y: { title: { display: true, text: 'Equity ($)' } } } } });

                    const conditionProfits = { killZone: { inZone: [], outZone: [] }, fvg: { withFvg: [], withoutFvg: [] }, marketStructure: { aligned: [], notAligned: [] }, volume: { withConfirmation: [], withoutConfirmation: [] }, ote: { withOte: [], withoutOte: [] }, ltfBreak: { withBreak: [], withoutBreak: [] }, fib: { nearFib: [], notNearFib: [] }, orderBlock: { nearBlock: [], notNearBlock: [] } };
                    trades.forEach(trade => {
                        const c = trade.trading_conditions;
                        if (c) {
                            conditionProfits.killZone[c.in_kill_zone ? 'inZone' : 'outZone'].push(trade.net_profit);
                            conditionProfits.fvg[c.has_fvg ? 'withFvg' : 'withoutFvg'].push(trade.net_profit);
                            const isAligned = c.has_market_structure && (trade.type === 'BUY' === c.market_structure_bullish);
                            conditionProfits.marketStructure[isAligned ? 'aligned' : 'notAligned'].push(trade.net_profit);
                            conditionProfits.volume[c.volume_confirmation ? 'withConfirmation' : 'withoutConfirmation'].push(trade.net_profit);
                            conditionProfits.ote[c.has_ote ? 'withOte' : 'withoutOte'].push(trade.net_profit);
                            conditionProfits.ltfBreak[c.has_ltf_break ? 'withBreak' : 'withoutBreak'].push(trade.net_profit);
                            conditionProfits.fib[c.near_fib_level ? 'nearFib' : 'notNearFib'].push(trade.net_profit);
                            conditionProfits.orderBlock[c.near_order_block ? 'nearBlock' : 'notNearBlock'].push(trade.net_profit);
                        }
                    });

                    const calculateAverage = (arr) => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
                    createOrUpdateChart('killZoneChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['In Zone Wins','In Zone Losses','Out Zone Wins','Out Zone Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.killZone.inZone, conditionProfits.killZone.outZone), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('killZoneChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['In Zone Profit','In Zone Loss','Out Zone Profit','Out Zone Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.killZone.inZone, conditionProfits.killZone.outZone), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('fvgImpactChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['With FVG Wins','With FVG Losses','Without FVG Wins','Without FVG Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.fvg.withFvg, conditionProfits.fvg.withoutFvg), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('fvgImpactChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['With FVG Profit','With FVG Loss','Without FVG Profit','Without FVG Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.fvg.withFvg, conditionProfits.fvg.withoutFvg), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('marketStructureChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['Aligned Wins','Aligned Losses','Not Aligned Wins','Not Aligned Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.marketStructure.aligned, conditionProfits.marketStructure.notAligned), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('marketStructureChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['Aligned Profit','Aligned Loss','Not Aligned Profit','Not Aligned Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.marketStructure.aligned, conditionProfits.marketStructure.notAligned), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('volumeConfirmationChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['With Confirmation Wins','With Confirmation Losses','Without Confirmation Wins','Without Confirmation Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.volume.withConfirmation, conditionProfits.volume.withoutConfirmation), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('volumeConfirmationChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['With Confirmation Profit','With Confirmation Loss','Without Confirmation Profit','Without Confirmation Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.volume.withConfirmation, conditionProfits.volume.withoutConfirmation), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('otePerformanceChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['With OTE Wins','With OTE Losses','Without OTE Wins','Without OTE Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.ote.withOte, conditionProfits.ote.withoutOte), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('otePerformanceChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['With OTE Profit','With OTE Loss','Without OTE Profit','Without OTE Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.ote.withOte, conditionProfits.ote.withoutOte), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('ltfBreakChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['With Break Wins','With Break Losses','Without Break Wins','Without Break Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.ltfBreak.withBreak, conditionProfits.ltfBreak.withoutBreak), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('ltfBreakChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['With Break Profit','With Break Loss','Without Break Profit','Without Break Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.ltfBreak.withBreak, conditionProfits.ltfBreak.withoutBreak), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('fibPerformanceChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['Near Fib Wins','Near Fib Losses','Not Near Fib Wins','Not Near Fib Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.fib.nearFib, conditionProfits.fib.notNearFib), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('fibPerformanceChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['Near Fib Profit','Near Fib Loss','Not Near Fib Profit','Not Near Fib Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.fib.nearFib, conditionProfits.fib.notNearFib), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('orderBlockChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['Near Block Wins','Near Block Losses','Not Near Block Wins','Not Near Block Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.orderBlock.nearBlock, conditionProfits.orderBlock.notNearBlock), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('orderBlockChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['Near Block Profit','Near Block Loss','Not Near Block Profit','Not Near Block Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.orderBlock.nearBlock, conditionProfits.orderBlock.notNearBlock), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });

                    // --- Hourly Performance ---
                    const hourlyProfits = Array(24).fill(0);
                    trades.forEach(trade => {
                        const hour = new Date(trade.open_time).getHours();
                        hourlyProfits[hour] += trade.net_profit;
                    });
                    createOrUpdateChart('hourlyPerformanceChart', { type: 'bar', data: { labels: Array.from({length:24},(_,i)=>i+':00'), datasets: [{ label: 'Net Profit', data: hourlyProfits, backgroundColor: '#00b894' }] }, options: { plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } } });

                    // --- Daily Performance ---
                    const dailyProfitsMap = {};
                    trades.forEach(trade => {
                        const d = new Date(trade.open_time);
                        const key = d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0');
                        if (!dailyProfitsMap[key]) dailyProfitsMap[key] = 0;
                        dailyProfitsMap[key] += trade.net_profit;
                    });
                    const dailyLabels = Object.keys(dailyProfitsMap).sort();
                    const dailyProfits = dailyLabels.map(k => dailyProfitsMap[k]);
                    createOrUpdateChart('dailyPerformanceChart', { type: 'bar', data: { labels: dailyLabels, datasets: [{ label: 'Net Profit', data: dailyProfits, backgroundColor: '#0984e3' }] }, options: { plugins: { legend: { display: false } }, scales: { x: { ticks: { maxTicksLimit: 10 } }, y: { beginAtZero: true } } } });

                    // --- Monthly Performance ---
                    const monthlyProfitsMap = {};
                    trades.forEach(trade => {
                        const d = new Date(trade.open_time);
                        const key = d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0');
                        if (!monthlyProfitsMap[key]) monthlyProfitsMap[key] = 0;
                        monthlyProfitsMap[key] += trade.net_profit;
                    });
                    const monthlyLabels = Object.keys(monthlyProfitsMap).sort();
                    const monthlyProfits = monthlyLabels.map(k => monthlyProfitsMap[k]);
                    createOrUpdateChart('monthlyPerformanceChart', { type: 'bar', data: { labels: monthlyLabels, datasets: [{ label: 'Net Profit', data: monthlyProfits, backgroundColor: '#fdcb6e' }] }, options: { plugins: { legend: { display: false } }, scales: { x: { ticks: { maxTicksLimit: 10 } }, y: { beginAtZero: true } } } });

                    // --- Additional Analytics and Charts ---
                    // 1. Trade Duration Distribution
                    const durationBuckets = [0, 5, 15, 30, 60, 120, 240, 480, 1440]; // in minutes
                    const durationLabels = ['<5m','5-15m','15-30m','30-60m','1-2h','2-4h','4-8h','8-24h','>24h'];
                    const durationCounts = Array(durationLabels.length).fill(0);
                    const durationProfits = Array(durationLabels.length).fill(0);
                    const tradeDurations = trades.map(trade => {
                        const open = new Date(trade.open_time);
                        const close = new Date(trade.close_time);
                        return (close - open) / 60000; // duration in minutes
                    });
                    tradeDurations.forEach((dur, i) => {
                        let idx = durationBuckets.findIndex((b, j) => dur < (durationBuckets[j+1] || Infinity));
                        if (idx === -1) idx = durationLabels.length - 1;
                        durationCounts[idx]++;
                        durationProfits[idx] += trades[i].net_profit;
                    });
                    createOrUpdateChart('tradeDurationChart', { type: 'bar', data: { labels: durationLabels, datasets: [{ label: 'Trades', data: durationCounts, backgroundColor: '#007bff' }] }, options: { plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } } });
                    // 2. Win/Loss Distribution
                    const winCount = trades.filter(t => t.net_profit > 0).length;
                    const lossCount = trades.filter(t => t.net_profit < 0).length;
                    createOrUpdateChart('winLossDistributionChart', { type: 'pie', data: { labels: ['Wins','Losses'], datasets: [{ data: [winCount, lossCount], backgroundColor: ['#28a745','#dc3545'] }] }, options: { plugins: { legend: { display: true } } } });
                    // 3. Trade Volume by Hour
                    const volumeByHour = Array(24).fill(0);
                    trades.forEach(trade => { volumeByHour[new Date(trade.open_time).getHours()] += trade.volume; });
                    createOrUpdateChart('tradeVolumeByHourChart', { type: 'bar', data: { labels: Array.from({length:24},(_,i)=>i+':00'), datasets: [{ label: 'Volume', data: volumeByHour, backgroundColor: '#6c63ff' }] }, options: { plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } } });
                    // 4. Average Profit by Trade Duration
                    const avgProfitByDuration = durationProfits.map((sum, i) => durationCounts[i] ? sum/durationCounts[i] : 0);
                    createOrUpdateChart('profitByDurationChart', { type: 'bar', data: { labels: durationLabels, datasets: [{ label: 'Avg Profit', data: avgProfitByDuration, backgroundColor: '#ffa600' }] }, options: { plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } } });
                    // 5. Trade Entry Times (histogram by hour)
                    const entryTimes = Array(24).fill(0);
                    trades.forEach(trade => { entryTimes[new Date(trade.open_time).getHours()]++; });
                    createOrUpdateChart('entryTimesChart', { type: 'bar', data: { labels: Array.from({length:24},(_,i)=>i+':00'), datasets: [{ label: 'Entries', data: entryTimes, backgroundColor: '#00b894' }] }, options: { plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } } });
                    // 6. Long vs Short Performance
                    const longTrades = trades.filter(t => t.type === 'BUY');
                    const shortTrades = trades.filter(t => t.type === 'SELL');
                    createOrUpdateChart('longShortChart', { type: 'bar', data: { labels: ['Long','Short'], datasets: [ { label: 'Count', data: [longTrades.length, shortTrades.length], backgroundColor: '#0984e3' }, { label: 'Avg Profit', data: [longTrades.length ? longTrades.reduce((a,b)=>a+b.net_profit,0)/longTrades.length : 0, shortTrades.length ? shortTrades.reduce((a,b)=>a+b.net_profit,0)/shortTrades.length : 0], backgroundColor: '#fdcb6e' } ] }, options: { plugins: { legend: { display: true } }, scales: { y: { beginAtZero: true } } } });
                    // 7. Consecutive Wins/Losses
                    let maxWinStreak = 0, maxLossStreak = 0, curWin = 0, curLoss = 0;
                    const streaks = [];
                    trades.forEach(trade => {
                        if (trade.net_profit > 0) {
                            curWin++; maxWinStreak = Math.max(maxWinStreak, curWin); curLoss = 0;
                        } else if (trade.net_profit < 0) {
                            curLoss++; maxLossStreak = Math.max(maxLossStreak, curLoss); curWin = 0;
                        } else { curWin = 0; curLoss = 0; }
                        streaks.push({win: curWin, loss: curLoss});
                    });
                    createOrUpdateChart('consecutiveChart', { type: 'line', data: { labels: trades.map((_,i)=>i+1), datasets: [ { label: 'Win Streak', data: streaks.map(s=>s.win), borderColor: '#00b894', fill: false }, { label: 'Loss Streak', data: streaks.map(s=>s.loss), borderColor: '#d63031', fill: false } ] }, options: { plugins: { legend: { display: true } }, scales: { y: { beginAtZero: true } } } });
                    // 8. Profit Distribution
                    const profits = trades.map(t => t.net_profit);
                    const profitBins = Array.from({length: 20}, (_,i) => i-10);
                    const profitHist = Array(20).fill(0);
                    profits.forEach(p => {
                        let idx = Math.floor((p+100)/10); // bin width 10, center at 0
                        idx = Math.max(0, Math.min(profitHist.length-1, idx));
                        profitHist[idx]++;
                    });
                    createOrUpdateChart('profitDistributionChart', { type: 'bar', data: { labels: profitBins.map(b=>`${b*10}`), datasets: [{ label: 'Trades', data: profitHist, backgroundColor: '#636e72' }] }, options: { plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } } });

                    // --- Enhanced Trading Conditions Analysis (Pie Charts for Raw Counts and Profits) ---
                    function winLossPieData(arr1, arr2) {
                        return [
                            arr1.filter(x => x > 0).length,
                            arr1.filter(x => x < 0).length,
                            arr2.filter(x => x > 0).length,
                            arr2.filter(x => x < 0).length
                        ];
                    }
                    function profitLossPieData(arr1, arr2) {
                        return [
                            arr1.filter(x => x > 0).reduce((a,b)=>a+b,0),
                            Math.abs(arr1.filter(x => x < 0).reduce((a,b)=>a+b,0)),
                            arr2.filter(x => x > 0).reduce((a,b)=>a+b,0),
                            Math.abs(arr2.filter(x => x < 0).reduce((a,b)=>a+b,0))
                        ];
                    }
                    // Kill Zone
                    createOrUpdateChart('killZoneChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['In Zone Wins','In Zone Losses','Out Zone Wins','Out Zone Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.killZone.inZone, conditionProfits.killZone.outZone), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('killZoneChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['In Zone Profit','In Zone Loss','Out Zone Profit','Out Zone Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.killZone.inZone, conditionProfits.killZone.outZone), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    // FVG Impact
                    createOrUpdateChart('fvgImpactChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['With FVG Wins','With FVG Losses','Without FVG Wins','Without FVG Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.fvg.withFvg, conditionProfits.fvg.withoutFvg), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('fvgImpactChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['With FVG Profit','With FVG Loss','Without FVG Profit','Without FVG Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.fvg.withFvg, conditionProfits.fvg.withoutFvg), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    // Market Structure
                    createOrUpdateChart('marketStructureChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['Aligned Wins','Aligned Losses','Not Aligned Wins','Not Aligned Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.marketStructure.aligned, conditionProfits.marketStructure.notAligned), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('marketStructureChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['Aligned Profit','Aligned Loss','Not Aligned Profit','Not Aligned Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.marketStructure.aligned, conditionProfits.marketStructure.notAligned), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    // Volume Confirmation
                    createOrUpdateChart('volumeConfirmationChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['With Confirmation Wins','With Confirmation Losses','Without Confirmation Wins','Without Confirmation Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.volume.withConfirmation, conditionProfits.volume.withoutConfirmation), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('volumeConfirmationChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['With Confirmation Profit','With Confirmation Loss','Without Confirmation Profit','Without Confirmation Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.volume.withConfirmation, conditionProfits.volume.withoutConfirmation), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    // OTE
                    createOrUpdateChart('otePerformanceChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['With OTE Wins','With OTE Losses','Without OTE Wins','Without OTE Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.ote.withOte, conditionProfits.ote.withoutOte), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('otePerformanceChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['With OTE Profit','With OTE Loss','Without OTE Profit','Without OTE Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.ote.withOte, conditionProfits.ote.withoutOte), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    // LTF Break
                    createOrUpdateChart('ltfBreakChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['With Break Wins','With Break Losses','Without Break Wins','Without Break Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.ltfBreak.withBreak, conditionProfits.ltfBreak.withoutBreak), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('ltfBreakChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['With Break Profit','With Break Loss','Without Break Profit','Without Break Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.ltfBreak.withBreak, conditionProfits.ltfBreak.withoutBreak), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    // Fibonacci
                    createOrUpdateChart('fibPerformanceChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['Near Fib Wins','Near Fib Losses','Not Near Fib Wins','Not Near Fib Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.fib.nearFib, conditionProfits.fib.notNearFib), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('fibPerformanceChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['Near Fib Profit','Near Fib Loss','Not Near Fib Profit','Not Near Fib Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.fib.nearFib, conditionProfits.fib.notNearFib), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    // Order Block
                    createOrUpdateChart('orderBlockChartCount', {
                        type: 'pie',
                        data: {
                            labels: ['Near Block Wins','Near Block Losses','Not Near Block Wins','Not Near Block Losses'],
                            datasets: [{ data: winLossPieData(conditionProfits.orderBlock.nearBlock, conditionProfits.orderBlock.notNearBlock), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });
                    createOrUpdateChart('orderBlockChartProfit', {
                        type: 'pie',
                        data: {
                            labels: ['Near Block Profit','Near Block Loss','Not Near Block Profit','Not Near Block Loss'],
                            datasets: [{ data: profitLossPieData(conditionProfits.orderBlock.nearBlock, conditionProfits.orderBlock.notNearBlock), backgroundColor: ['#28a745','#dc3545','#a3e635','#f87171'] }]
                        },
                        options: { plugins: { legend: { display: true } } }
                    });

                    // Display Strategy Parameters
                    displayStrategyParameters(test.parameters);
                })
                .catch(error => {
                    console.error('Error fetching or processing test data:', error);
                    container.innerHTML = `<h1>Error</h1><p>Could not load test data. Please check the console for details.</p><a href="/dashboard">&larr; Back to Dashboard</a>`;
                });
        });

        function displayStrategyParameters(parametersJson) {
            const parametersSection = document.getElementById('parameters-section');

            if (!parametersJson) {
                parametersSection.innerHTML = '<p style="text-align: center; color: #666;">No parameters available for this test.</p>';
                return;
            }

            try {
                const params = JSON.parse(parametersJson);
                let html = '<div class="parameters-container">';

                // Group parameters by category
                const categories = {
                    'Risk Management': ['RiskPercent', 'RRRatio', 'MinLotSize', 'MaxLotSize', 'MaxPositions'],
                    'Stop Loss Settings': ['UseATRStopLoss', 'ATRMultiplier', 'ATRPeriod', 'UseTrailingStop', 'TrailStartPercent', 'TrailDistancePercent'],
                    'Imbalance Settings': ['ImbalanceConfirmationBars', 'MinImbalanceRatio', 'MinImbalanceVolume', 'RequireStackedImbalance', 'RequireVolumeConfirmation'],
                    'Trading Settings': ['RequireConfirmation', 'MagicNumber'],
                    'News Filter': ['NewsBlockMinutesBefore', 'NewsBlockMinutesAfter', 'BlockHighImpactOnly'],
                    'ICT Kill Zone Settings': ['UseKillZones', 'UseLondonKillZone', 'LondonKillZoneStart', 'LondonKillZoneEnd', 'UseNewYorkKillZone', 'NewYorkKillZoneStart', 'NewYorkKillZoneEnd', 'UseAsianKillZone', 'AsianKillZoneStart', 'AsianKillZoneEnd', 'UseLondonOpenKillZone', 'LondonOpenKillZoneStart', 'LondonOpenKillZoneEnd', 'UseNewYorkOpenKillZone', 'NewYorkOpenKillZoneStart', 'NewYorkOpenKillZoneEnd'],
                    'Market Structure & Bias': ['UseMarketStructureFilter', 'StructureTimeframe', 'StructureLookback', 'RequireLiquiditySweep', 'LiquiditySweepLookback', 'MinSweepDistance'],
                    'Optimal Trade Entry (OTE) Settings': ['UseOTEFilter', 'UseFibonacciLevels', 'FibLevel1', 'FibLevel2', 'FibLevel3', 'FibLevel4', 'UseOrderBlocks', 'OrderBlockLookback', 'OrderBlockMinSize'],
                    'Standard Deviation Settings': ['UseStandardDeviation', 'StdDevPeriod', 'StdDevMultiplier'],
                    'Lower Timeframe Analysis': ['UseLowerTimeframeTriggers', 'LowerTimeframe', 'LTFStructureLookback', 'RequireLTFConfirmation', 'RequireOTERetest', 'OTERetestTolerance', 'MinLTFConditions', 'RequireStructureBreak', 'AllowLTFOnlyTrades', 'RequireMarketStructureForLTF']
                };

                for (const [category, paramNames] of Object.entries(categories)) {
                    const categoryParams = {};
                    let hasParams = false;

                    // Collect parameters for this category
                    for (const paramName of paramNames) {
                        if (params.hasOwnProperty(paramName)) {
                            categoryParams[paramName] = params[paramName];
                            hasParams = true;
                        }
                    }

                    if (hasParams) {
                        html += `
                            <div class="parameter-category">
                                <h3 class="category-header" onclick="toggleCategory(this)">
                                    ${category} <span class="toggle-icon"></span>
                                </h3>
                                <div class="category-content">
                                    <div class="parameter-grid">
                        `;

                        for (const [paramName, paramValue] of Object.entries(categoryParams)) {
                            const displayName = paramName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                            const displayValue = formatParameterValue(paramValue);

                            html += `
                                <div class="parameter-item">
                                    <div class="parameter-name">${displayName}</div>
                                    <div class="parameter-value">${displayValue}</div>
                                </div>
                            `;
                        }

                        html += `
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }

                html += '</div>';
                parametersSection.innerHTML = html;

            } catch (error) {
                console.error('Error parsing parameters:', error);
                parametersSection.innerHTML = '<p style="text-align: center; color: #666;">Error parsing parameters.</p>';
            }
        }

        function formatParameterValue(value) {
            if (typeof value === 'boolean') {
                return value ? '<span class="value-true"></span>' : '<span class="value-false"></span>';
            }
            if (typeof value === 'number') {
                return value.toFixed(2);
            }
            return value;
        }

        function toggleCategory(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '';
            } else {
                content.style.display = 'none';
                icon.textContent = '';
            }
        }
    </script>
</body>
</html>
